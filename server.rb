# frozen_string_literal: true

require 'sinatra'
require 'logger'
require 'json'
require 'openssl'
require 'jwt'
require 'rest-client'

set :bind, '127.0.0.1'
set :port, 3000

class GHAapp < Sinatra::Application
  # Notice that the private key must be in PEM format, but the newlines should be stripped and replaced with
  # the literal `\n`. This can be done in the terminal as such:
  # export GITHUB_PRIVATE_KEY=`awk '{printf "%s\\n", $0}' private-key.pem`
  PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n")) # convert newlines

  # You set the webhook secret when you create your app. This verifies that the webhook is really coming from GH.
  WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

  # Get the app identifier—an integer—from your app page after you create your app. This isn't actually a secret,
  # but it is something easier to configure at runtime.
  APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

  REPO_NAME = ENV['REPO_NAME']
  GH_USER = ENV['GH_USER']
  GH_PASS = ENV['GH_PASS']

  # Turning on Sinatra logging
  configure :development do
    set :logging, Logger::DEBUG
  end


  ########## Events

  post '/' do
    request.body.rewind
    payload_raw = request.body.read # We need the raw text of the body to check the webhook signature
    begin
      payload = JSON.parse payload_raw
    rescue
      payload = {}
    end

    # Check X-Hub-Signature to confirm that this webhook was generated by GitHub, and not a malicious third party.
    # The way this works is: We have registered with GitHub a secret, and we have stored it locally in WEBHOOK_SECRET.
    # GitHub will cryptographically sign the request payload with this secret. We will do the same, and if the results
    # match, then we know that the request is from GitHub (or, at least, from someone who knows the secret!)
    # If they don't match, this request is an attack, and we should reject it.
    # The signature comes in with header x-hub-signature, and looks like "sha1=123456"
    # We should take the left hand side as the signature method, and the right hand side as the
    # HMAC digest (the signature) itself.
    their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
    method, their_digest = their_signature_header.split('=')
    our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, payload_raw)
    halt 401 unless their_digest == our_digest

    # Determine what kind of event this is, and take action as appropriate
    logger.debug "---- received event #{request.env['HTTP_X_GITHUB_EVENT']}"
    logger.debug "----         action #{payload['action']}" unless payload['action'].nil?

    case request.env['HTTP_X_GITHUB_EVENT']
    when 'push'
      if payload['ref'] == 'refs/heads/test_env_branch'
        return_branch_diff_vs_master
      end
    end

    'ok' # we have to return _something_ ;)
  end


  ########## Helpers

  helpers do
    def return_branch_diff_vs_master
      # grab the last x unique branches merged to master (based on commits?)
      # grab the last x unique branches merged to test_env_branch (based on commits?)
      # find the most recent shared branch between master and test_env_branch
      # print unique branches merged to test_env_branch since shared branch


      logger.debug commits_diverging_from_master("test_env_branch")
      # logger.debug branch_diffs
      # logger.debug `curl -u 'gwieneke' 'https://api.github.com/repos/gwieneke/gw_test/branches/master'`
      true
    end

    def branch_diffs
      # branch_names = ["react", "sanbox", "sandbox2", "sandbox3"]
      branch_names = ["test_env_branch"]
      branch_names.each do |br|
        logger.debug br + "divergent commits:"
        logger.debug commits_diverging_from_master(br)
      end
    end

    def commits_diverging_from_master(branch_name)
      master_shas = recent_100_shas_for_branch("master")
      branch_shas = recent_100_shas_for_branch(branch_name)

      intersection_index = branch_shas.find_index((master_shas & branch_shas).first)
      branch_shas[0..(intersection_index - 1)]
    end

    def recent_100_shas_for_branch(branch_name)
      commits = recent_100_commits_for_branch(branch_name)
      commits.map { |c| c["sha"] }
    end

    def recent_100_commits_for_branch(branch_name)
      branch_api_url = REPO_NAME + "/branches/#{branch_name}"
      branch_data = return_api_json(branch_api_url)
      sha = branch_data["commit"]["sha"]
      commit_api_url = REPO_NAME + "/commits?per_page=100&sha=#{sha}"
      return_api_json(commit_api_url)
    end

    def return_api_json(api_url, params = {})
      uri = URI.encode(api_url)
      api_response = RestClient::Request.execute(
        method: :get,
        url: uri,
        username: GH_USER,
        password: GH_PASS,
        headers: {params: params}
      )
      JSON.parse(api_response)
    end
  end

  # Finally some logic to let us run this server directly from the commandline, or with Rack
  # $0 is the executed file
  # __FILE__ is the current file
  # If they are the same—that is, we are running this file directly, call the Sinatra run method
  run! if __FILE__ == $0
end
